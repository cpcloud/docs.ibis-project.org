
.. code:: python

    import ibis
    import os
    hdfs_port = os.environ.get('IBIS_WEBHDFS_PORT', 50070)
    
    ic = ibis.impala_connect(host='quickstart.cloudera', database='ibis_testing')
    hdfs = ibis.hdfs_connect(port=hdfs_port)
    con = ibis.make_client(ic, hdfs_client=hdfs)
    
    ibis.options.interactive = True

Type casting
============

The Ibis type system is pretty basic and will get better (and more
documented over time). It maps directly onto the current Impala type
system

-  ``int8``
-  ``int16``
-  ``int32``
-  ``int64``
-  ``boolean``
-  ``float``
-  ``double``
-  ``string``
-  ``timestamp``
-  ``decimal($precision, $scale)``

These type names can be used to cast from one type to another

.. code:: python

    table = con.table('functional_alltypes')
    table.string_col.cast('double').sum()




.. parsed-literal::

    32850.0



.. code:: python

    table.string_col.cast('decimal(12,2)').sum()




.. parsed-literal::

    Decimal('32850.00')



Case / if-then-else expressions
===============================

We support a number of variants of the SQL-equivalent ``CASE``
expression, and will add more API functions over time to meet different
use cases and enhance the expressiveness of any branching-based value
logic.

.. code:: python

    expr = (table.string_col
            .case()
            .when('4', 'fee')
            .when('7', 'fi')
            .when('1', 'fo')
            .when('0', 'fum')
            .else_(table.string_col)
            .end()
            .name('new_strings'))
    
    expr.value_counts()




.. parsed-literal::

      new_strings  count
    0           6    730
    1          fi    730
    2         fee    730
    3           9    730
    4           8    730
    5          fo    730
    6           3    730
    7           2    730
    8         fum    730
    9           5    730



If the ``else_`` default condition is not provided, any values not
matching one of the conditions will be ``NULL``.

.. code:: python

    expr = (table.string_col
            .case()
            .when('4', 'fee')
            .when('7', 'fi')
            .end()
            .name('with_nulls'))
    
    expr.value_counts()




.. parsed-literal::

      with_nulls  count
    0       None   5840
    1         fi    730
    2        fee    730



To test for an arbitrary series of boolean conditions, use the ``case``
API method and pass any boolean expressions potentially involving
columns of the table:

.. code:: python

    expr = (ibis.case()
            .when(table.int_col > 5, table.bigint_col * 2)
            .when(table.int_col > 2, table.bigint_col)
            .else_(table.int_col)
            .end())
    
    table['id', 'int_col', 'bigint_col', expr.name('case_result')].limit(20)




.. parsed-literal::

            id  int_col  bigint_col  case_result
    0     4550        0           0            0
    1     4551        1          10            1
    2     4552        2          20            2
    3     4553        3          30           30
    4     4554        4          40           40
    5     4555        5          50           50
    6     4556        6          60          120
    7     4557        7          70          140
    8     4558        8          80          160
    9     4559        9          90          180
    10    4560        0           0            0
    11    4561        1          10            1
    12    4562        2          20            2
    13    4563        3          30           30
    14    4564        4          40           40
    15    4565        5          50           50
    16    4566        6          60          120
    17    4567        7          70          140
    18    4568        8          80          160
    19    4569        9          90          180
    20    4570        0           0            0
    21    4571        1          10            1
    22    4572        2          20            2
    23    4573        3          30           30
    24    4574        4          40           40
    25    4575        5          50           50
    26    4576        6          60          120
    27    4577        7          70          140
    28    4578        8          80          160
    29    4579        9          90          180
    ...    ...      ...         ...          ...
    7270  3620        0           0            0
    7271  3621        1          10            1
    7272  3622        2          20            2
    7273  3623        3          30           30
    7274  3624        4          40           40
    7275  3625        5          50           50
    7276  3626        6          60          120
    7277  3627        7          70          140
    7278  3628        8          80          160
    7279  3629        9          90          180
    7280  3630        0           0            0
    7281  3631        1          10            1
    7282  3632        2          20            2
    7283  3633        3          30           30
    7284  3634        4          40           40
    7285  3635        5          50           50
    7286  3636        6          60          120
    7287  3637        7          70          140
    7288  3638        8          80          160
    7289  3639        9          90          180
    7290  3640        0           0            0
    7291  3641        1          10            1
    7292  3642        2          20            2
    7293  3643        3          30           30
    7294  3644        4          40           40
    7295  3645        5          50           50
    7296  3646        6          60          120
    7297  3647        7          70          140
    7298  3648        8          80          160
    7299  3649        9          90          180
    
    [7300 rows x 4 columns]



Simple ternary-cases (like the Python ``X if COND else Y``) can be
written using the ``ifelse`` function:

.. code:: python

    expr = ((table.int_col > 5)
            .ifelse(table.bigint_col / 2, table.bigint_col * 2)
            .name('ifelse_result'))
    
    table['int_col', 'bigint_col', expr].limit(10)




.. parsed-literal::

          int_col  bigint_col  ifelse_result
    0           0           0              0
    1           1          10             20
    2           2          20             40
    3           3          30             60
    4           4          40             80
    5           5          50            100
    6           6          60             30
    7           7          70             35
    8           8          80             40
    9           9          90             45
    10          0           0              0
    11          1          10             20
    12          2          20             40
    13          3          30             60
    14          4          40             80
    15          5          50            100
    16          6          60             30
    17          7          70             35
    18          8          80             40
    19          9          90             45
    20          0           0              0
    21          1          10             20
    22          2          20             40
    23          3          30             60
    24          4          40             80
    25          5          50            100
    26          6          60             30
    27          7          70             35
    28          8          80             40
    29          9          90             45
    ...       ...         ...            ...
    7270        0           0              0
    7271        1          10             20
    7272        2          20             40
    7273        3          30             60
    7274        4          40             80
    7275        5          50            100
    7276        6          60             30
    7277        7          70             35
    7278        8          80             40
    7279        9          90             45
    7280        0           0              0
    7281        1          10             20
    7282        2          20             40
    7283        3          30             60
    7284        4          40             80
    7285        5          50            100
    7286        6          60             30
    7287        7          70             35
    7288        8          80             40
    7289        9          90             45
    7290        0           0              0
    7291        1          10             20
    7292        2          20             40
    7293        3          30             60
    7294        4          40             80
    7295        5          50            100
    7296        6          60             30
    7297        7          70             35
    7298        8          80             40
    7299        9          90             45
    
    [7300 rows x 3 columns]



Set membership
==============

The ``isin`` and ``notin`` functions are like their pandas counterparts.
These can take:

-  A list of value expressions, either literal values or other column
   expressions
-  An array/column expression of some kind

.. code:: python

    bool_clause = table.string_col.notin(['1', '4', '7'])
    table[bool_clause].string_col.value_counts()




.. parsed-literal::

      string_col  count
    0          6    730
    1          8    730
    2          2    730
    3          5    730
    4          9    730
    5          0    730
    6          3    730



You can also check for membership in an array. Here is an example of
filtering based on the top 3 (ignoring ties) most frequently-occurring
values in the ``string_col`` column of alltypes:

.. code:: python

    top_strings = table.string_col.value_counts().limit(3).string_col
    top_filter = table.string_col.isin(top_strings)
    expr = table[top_filter]
    
    expr.count()




.. parsed-literal::

    2190



This is a common enough operation that we provide a special analytical
filter function ``topk``:

.. code:: python

    table[table.string_col.topk(3)].count()




.. parsed-literal::

    2190



Cool, huh? More on ``topk`` later.

Null-ness
=========

Like their pandas equivalents, the ``isnull`` and ``notnull`` functions
return TRue values if the values are null, or non-null, respectively.
For example:

.. code:: python

    expr = (table.string_col
            .case()
            .when('4', 'fee')
            .when('7', 'fi')
            .when('1', 'fo')
            .end()
            .name('new_strings'))
    
    expr.isnull().value_counts()




.. parsed-literal::

      unnamed  count
    0   False   2190
    1    True   5110



Functions like ``isnull`` can be combined with ``case`` expressions or
functions like ``ifelse`` to replace null values with some other value.
``ifelse`` here will use the first value supplied for any ``True`` value
and the second value for any ``False`` value. Either value can be a
scalar or array.

.. code:: python

    expr2 = expr.isnull().ifelse('was null', expr).name('strings')
    expr2.value_counts()




.. parsed-literal::

        strings  count
    0  was null   5110
    1        fi    730
    2        fo    730
    3       fee    730



Distinct-based operations
=========================

Ibis supports using ``distinct`` to remove duplicate rows or values on
tables or arrays. For example:

.. code:: python

    table['int_col', 'bigint_col'].distinct()




.. parsed-literal::

       int_col  bigint_col
    0        6          60
    1        0           0
    2        8          80
    3        3          30
    4        9          90
    5        7          70
    6        2          20
    7        1          10
    8        4          40
    9        5          50



.. code:: python

    table.string_col.distinct()




.. parsed-literal::

    0    6
    1    4
    2    7
    3    1
    4    8
    5    9
    6    3
    7    2
    8    5
    9    0
    Name: string_col, dtype: object



This can be combined with ``count`` to form a reduction metric:

.. code:: python

    metric = (table.bigint_col
              .distinct().count()
              .name('unique_bigints'))

This is common enough to have a shortcut ``nunique``:

.. code:: python

    table.string_col.nunique()




.. parsed-literal::

    10



String operations
=================

What's supported is pretty basic right now. We intend to support the
full gamut of regular expression munging with a nice API, though in some
cases some work will be required on Impala's backend to support
everything.

.. code:: python

    nation = con.table('tpch_nation')
    nation.limit(5)




.. parsed-literal::

        n_nationkey          n_name  n_regionkey  \
    0             0         ALGERIA            0   
    1             1       ARGENTINA            1   
    2             2          BRAZIL            1   
    3             3          CANADA            1   
    4             4           EGYPT            4   
    5             5        ETHIOPIA            0   
    6             6          FRANCE            3   
    7             7         GERMANY            3   
    8             8           INDIA            2   
    9             9       INDONESIA            2   
    10           10            IRAN            4   
    11           11            IRAQ            4   
    12           12           JAPAN            2   
    13           13          JORDAN            4   
    14           14           KENYA            0   
    15           15         MOROCCO            0   
    16           16      MOZAMBIQUE            0   
    17           17            PERU            1   
    18           18           CHINA            2   
    19           19         ROMANIA            3   
    20           20    SAUDI ARABIA            4   
    21           21         VIETNAM            2   
    22           22          RUSSIA            3   
    23           23  UNITED KINGDOM            3   
    24           24   UNITED STATES            1   
    
                                                n_comment  
    0    haggle. carefully final deposits detect slyly...  
    1   al foxes promise slyly according to the regula...  
    2   y alongside of the pending deposits. carefully...  
    3   eas hang ironic, silent packages. slyly regula...  
    4   y above the carefully unusual theodolites. fin...  
    5                     ven packages wake quickly. regu  
    6              refully final requests. regular, ironi  
    7   l platelets. regular accounts x-ray: unusual, ...  
    8   ss excuses cajole slyly across the packages. d...  
    9    slyly express asymptotes. regular deposits ha...  
    10  efully alongside of the slyly final dependenci...  
    11  nic deposits boost atop the quickly final requ...  
    12               ously. final, express gifts cajole a  
    13  ic deposits are blithely about the carefully r...  
    14   pending excuses haggle furiously deposits. pe...  
    15  rns. blithely bold courts among the closely re...  
    16      s. ironic, unusual asymptotes wake blithely r  
    17  platelets. blithely pending dependencies use f...  
    18  c dependencies. furiously express notornis sle...  
    19  ular asymptotes are about the furious multipli...  
    20  ts. silent requests haggle. closely express pa...  
    21     hely enticingly express accounts. even, final   
    22   requests against the platelets use never acco...  
    23  eans boost carefully special requests. account...  
    24  y final packages. slow foxes cajole quickly. q...  



At the moment, basic substring operations (``substr``, with conveniences
``left`` and ``right``) and Python-like APIs such as ``lower`` and
``upper`` (for case normalization) are supported. So you could count
first letter occurrences in a string column like so:

.. code:: python

    expr = nation.n_name.lower().left(1).name('first_letter')
    expr.value_counts().sort_by(('count', False))




.. parsed-literal::

       first_letter  count
    0             i      4
    1             a      2
    2             c      2
    3             j      2
    4             u      2
    5             m      2
    6             r      2
    7             e      2
    8             f      1
    9             v      1
    10            p      1
    11            b      1
    12            k      1
    13            s      1
    14            g      1



For fuzzy and regex filtering/searching, you can use one of the
following

-  ``like``, works as the SQL ``LIKE`` keyword
-  ``rlike``, like ``re.search`` or SQL ``RLIKE``
-  ``contains``, like ``x in str_value`` in Python

.. code:: python

    nation[nation.n_name.like('%GE%')]




.. parsed-literal::

       n_nationkey     n_name  n_regionkey  \
    0            0    ALGERIA            0   
    1            1  ARGENTINA            1   
    2            7    GERMANY            3   
    
                                               n_comment  
    0   haggle. carefully final deposits detect slyly...  
    1  al foxes promise slyly according to the regula...  
    2  l platelets. regular accounts x-ray: unusual, ...  



.. code:: python

    nation[nation.n_name.lower().rlike('.*ge.*')]




.. parsed-literal::

       n_nationkey     n_name  n_regionkey  \
    0            0    ALGERIA            0   
    1            1  ARGENTINA            1   
    2            7    GERMANY            3   
    
                                               n_comment  
    0   haggle. carefully final deposits detect slyly...  
    1  al foxes promise slyly according to the regula...  
    2  l platelets. regular accounts x-ray: unusual, ...  



.. code:: python

    nation[nation.n_name.lower().contains('ge')]




.. parsed-literal::

       n_nationkey     n_name  n_regionkey  \
    0            0    ALGERIA            0   
    1            1  ARGENTINA            1   
    2            7    GERMANY            3   
    
                                               n_comment  
    0   haggle. carefully final deposits detect slyly...  
    1  al foxes promise slyly according to the regula...  
    2  l platelets. regular accounts x-ray: unusual, ...  



Timestamp operations
====================

Date and time functionality is relatively limited at present compared
with pandas, but we'll get there. The main things we have right now are

-  Field access (year, month, day, ...)
-  Timedeltas
-  Comparisons with fixed timestamps

.. code:: python

    table = con.table('functional_alltypes')
    
    table[table.timestamp_col, table.timestamp_col.minute().name('minute')].limit(10)




.. parsed-literal::

                   timestamp_col  minute
    0    2010-07-01 00:00:00.000       0
    1    2010-07-01 00:01:00.000       1
    2    2010-07-01 00:02:00.100       2
    3    2010-07-01 00:03:00.300       3
    4    2010-07-01 00:04:00.600       4
    5    2010-07-01 00:05:00.100       5
    6    2010-07-01 00:06:00.150       6
    7    2010-07-01 00:07:00.210       7
    8    2010-07-01 00:08:00.280       8
    9    2010-07-01 00:09:00.360       9
    10   2010-07-02 00:10:00.450      10
    11   2010-07-02 00:11:00.450      11
    12   2010-07-02 00:12:00.460      12
    13   2010-07-02 00:13:00.480      13
    14   2010-07-02 00:14:00.510      14
    15   2010-07-02 00:15:00.550      15
    16   2010-07-02 00:16:00.600      16
    17   2010-07-02 00:17:00.660      17
    18   2010-07-02 00:18:00.730      18
    19   2010-07-02 00:19:00.810      19
    20   2010-07-03 00:20:00.900      20
    21   2010-07-03 00:21:00.900      21
    22   2010-07-03 00:22:00.910      22
    23   2010-07-03 00:23:00.930      23
    24   2010-07-03 00:24:00.960      24
    25   2010-07-03 00:25:01.000      25
    26   2010-07-03 00:26:01.500      26
    27   2010-07-03 00:27:01.110      27
    28   2010-07-03 00:28:01.180      28
    29   2010-07-03 00:29:01.260      29
    ...                      ...     ...
    7270 2009-02-26 04:10:11.250      10
    7271 2009-02-26 04:11:11.250      11
    7272 2009-02-26 04:12:11.260      12
    7273 2009-02-26 04:13:11.280      13
    7274 2009-02-26 04:14:11.310      14
    7275 2009-02-26 04:15:11.350      15
    7276 2009-02-26 04:16:11.400      16
    7277 2009-02-26 04:17:11.460      17
    7278 2009-02-26 04:18:11.530      18
    7279 2009-02-26 04:19:11.610      19
    7280 2009-02-27 04:20:11.700      20
    7281 2009-02-27 04:21:11.700      21
    7282 2009-02-27 04:22:11.710      22
    7283 2009-02-27 04:23:11.730      23
    7284 2009-02-27 04:24:11.760      24
    7285 2009-02-27 04:25:11.800      25
    7286 2009-02-27 04:26:11.850      26
    7287 2009-02-27 04:27:11.910      27
    7288 2009-02-27 04:28:11.980      28
    7289 2009-02-27 04:29:12.600      29
    7290 2009-02-28 04:30:12.150      30
    7291 2009-02-28 04:31:12.150      31
    7292 2009-02-28 04:32:12.160      32
    7293 2009-02-28 04:33:12.180      33
    7294 2009-02-28 04:34:12.210      34
    7295 2009-02-28 04:35:12.250      35
    7296 2009-02-28 04:36:12.300      36
    7297 2009-02-28 04:37:12.360      37
    7298 2009-02-28 04:38:12.430      38
    7299 2009-02-28 04:39:12.510      39
    
    [7300 rows x 2 columns]



Somewhat more comprehensively

.. code:: python

    def get_field(f):
        return getattr(table.timestamp_col, f)().name(f)
    
    fields = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond']
    projection = [table.timestamp_col] + [get_field(x) for x in fields]
    table[projection].limit(10)




.. parsed-literal::

                   timestamp_col  year  month  day  hour  minute  second  \
    0    2010-11-01 00:00:00.000  2010     11    1     0       0       0   
    1    2010-11-01 00:01:00.000  2010     11    1     0       1       0   
    2    2010-11-01 00:02:00.100  2010     11    1     0       2       0   
    3    2010-11-01 00:03:00.300  2010     11    1     0       3       0   
    4    2010-11-01 00:04:00.600  2010     11    1     0       4       0   
    5    2010-11-01 00:05:00.100  2010     11    1     0       5       0   
    6    2010-11-01 00:06:00.150  2010     11    1     0       6       0   
    7    2010-11-01 00:07:00.210  2010     11    1     0       7       0   
    8    2010-11-01 00:08:00.280  2010     11    1     0       8       0   
    9    2010-11-01 00:09:00.360  2010     11    1     0       9       0   
    10   2010-11-02 00:10:00.450  2010     11    2     0      10       0   
    11   2010-11-02 00:11:00.450  2010     11    2     0      11       0   
    12   2010-11-02 00:12:00.460  2010     11    2     0      12       0   
    13   2010-11-02 00:13:00.480  2010     11    2     0      13       0   
    14   2010-11-02 00:14:00.510  2010     11    2     0      14       0   
    15   2010-11-02 00:15:00.550  2010     11    2     0      15       0   
    16   2010-11-02 00:16:00.600  2010     11    2     0      16       0   
    17   2010-11-02 00:17:00.660  2010     11    2     0      17       0   
    18   2010-11-02 00:18:00.730  2010     11    2     0      18       0   
    19   2010-11-02 00:19:00.810  2010     11    2     0      19       0   
    20   2010-11-03 00:20:00.900  2010     11    3     0      20       0   
    21   2010-11-03 00:21:00.900  2010     11    3     0      21       0   
    22   2010-11-03 00:22:00.910  2010     11    3     0      22       0   
    23   2010-11-03 00:23:00.930  2010     11    3     0      23       0   
    24   2010-11-03 00:24:00.960  2010     11    3     0      24       0   
    25   2010-11-03 00:25:01.000  2010     11    3     0      25       1   
    26   2010-11-03 00:26:01.500  2010     11    3     0      26       1   
    27   2010-11-03 00:27:01.110  2010     11    3     0      27       1   
    28   2010-11-03 00:28:01.180  2010     11    3     0      28       1   
    29   2010-11-03 00:29:01.260  2010     11    3     0      29       1   
    ...                      ...   ...    ...  ...   ...     ...     ...   
    7270 2010-01-29 04:40:12.600  2010      1   29     4      40      12   
    7271 2010-01-29 04:41:12.600  2010      1   29     4      41      12   
    7272 2010-01-29 04:42:12.610  2010      1   29     4      42      12   
    7273 2010-01-29 04:43:12.630  2010      1   29     4      43      12   
    7274 2010-01-29 04:44:12.660  2010      1   29     4      44      12   
    7275 2010-01-29 04:45:12.700  2010      1   29     4      45      12   
    7276 2010-01-29 04:46:12.750  2010      1   29     4      46      12   
    7277 2010-01-29 04:47:12.810  2010      1   29     4      47      12   
    7278 2010-01-29 04:48:12.880  2010      1   29     4      48      12   
    7279 2010-01-29 04:49:12.960  2010      1   29     4      49      12   
    7280 2010-01-30 04:50:13.500  2010      1   30     4      50      13   
    7281 2010-01-30 04:51:13.500  2010      1   30     4      51      13   
    7282 2010-01-30 04:52:13.600  2010      1   30     4      52      13   
    7283 2010-01-30 04:53:13.800  2010      1   30     4      53      13   
    7284 2010-01-30 04:54:13.110  2010      1   30     4      54      13   
    7285 2010-01-30 04:55:13.150  2010      1   30     4      55      13   
    7286 2010-01-30 04:56:13.200  2010      1   30     4      56      13   
    7287 2010-01-30 04:57:13.260  2010      1   30     4      57      13   
    7288 2010-01-30 04:58:13.330  2010      1   30     4      58      13   
    7289 2010-01-30 04:59:13.410  2010      1   30     4      59      13   
    7290 2010-01-31 05:00:13.500  2010      1   31     5       0      13   
    7291 2010-01-31 05:01:13.500  2010      1   31     5       1      13   
    7292 2010-01-31 05:02:13.510  2010      1   31     5       2      13   
    7293 2010-01-31 05:03:13.530  2010      1   31     5       3      13   
    7294 2010-01-31 05:04:13.560  2010      1   31     5       4      13   
    7295 2010-01-31 05:05:13.600  2010      1   31     5       5      13   
    7296 2010-01-31 05:06:13.650  2010      1   31     5       6      13   
    7297 2010-01-31 05:07:13.710  2010      1   31     5       7      13   
    7298 2010-01-31 05:08:13.780  2010      1   31     5       8      13   
    7299 2010-01-31 05:09:13.860  2010      1   31     5       9      13   
    
          millisecond  
    0               0  
    1               0  
    2             100  
    3             300  
    4             600  
    5             100  
    6             150  
    7             210  
    8             280  
    9             360  
    10            450  
    11            450  
    12            460  
    13            480  
    14            510  
    15            550  
    16            600  
    17            660  
    18            730  
    19            810  
    20            900  
    21            900  
    22            910  
    23            930  
    24            960  
    25              0  
    26            500  
    27            110  
    28            180  
    29            260  
    ...           ...  
    7270          600  
    7271          600  
    7272          610  
    7273          630  
    7274          660  
    7275          700  
    7276          750  
    7277          810  
    7278          880  
    7279          960  
    7280          500  
    7281          500  
    7282          600  
    7283          800  
    7284          110  
    7285          150  
    7286          200  
    7287          260  
    7288          330  
    7289          410  
    7290          500  
    7291          500  
    7292          510  
    7293          530  
    7294          560  
    7295          600  
    7296          650  
    7297          710  
    7298          780  
    7299          860  
    
    [7300 rows x 8 columns]



For timestamp arithmetic and comparisons, check out functions in the top
level ``ibis`` namespace. This include things like ``day`` and
``second``, but also the ``ibis.timestamp`` function:

.. code:: python

    table[table.timestamp_col.min(), table.timestamp_col.max(), table.count().name('nrows')]




.. parsed-literal::

                min                     max  nrows
    0    2009-01-01 2010-12-31 05:09:13.860   7300
    1    2009-01-01 2010-12-31 05:09:13.860   7300
    2    2009-01-01 2010-12-31 05:09:13.860   7300
    3    2009-01-01 2010-12-31 05:09:13.860   7300
    4    2009-01-01 2010-12-31 05:09:13.860   7300
    5    2009-01-01 2010-12-31 05:09:13.860   7300
    6    2009-01-01 2010-12-31 05:09:13.860   7300
    7    2009-01-01 2010-12-31 05:09:13.860   7300
    8    2009-01-01 2010-12-31 05:09:13.860   7300
    9    2009-01-01 2010-12-31 05:09:13.860   7300
    10   2009-01-01 2010-12-31 05:09:13.860   7300
    11   2009-01-01 2010-12-31 05:09:13.860   7300
    12   2009-01-01 2010-12-31 05:09:13.860   7300
    13   2009-01-01 2010-12-31 05:09:13.860   7300
    14   2009-01-01 2010-12-31 05:09:13.860   7300
    15   2009-01-01 2010-12-31 05:09:13.860   7300
    16   2009-01-01 2010-12-31 05:09:13.860   7300
    17   2009-01-01 2010-12-31 05:09:13.860   7300
    18   2009-01-01 2010-12-31 05:09:13.860   7300
    19   2009-01-01 2010-12-31 05:09:13.860   7300
    20   2009-01-01 2010-12-31 05:09:13.860   7300
    21   2009-01-01 2010-12-31 05:09:13.860   7300
    22   2009-01-01 2010-12-31 05:09:13.860   7300
    23   2009-01-01 2010-12-31 05:09:13.860   7300
    24   2009-01-01 2010-12-31 05:09:13.860   7300
    25   2009-01-01 2010-12-31 05:09:13.860   7300
    26   2009-01-01 2010-12-31 05:09:13.860   7300
    27   2009-01-01 2010-12-31 05:09:13.860   7300
    28   2009-01-01 2010-12-31 05:09:13.860   7300
    29   2009-01-01 2010-12-31 05:09:13.860   7300
    ...         ...                     ...    ...
    7270 2009-01-01 2010-12-31 05:09:13.860   7300
    7271 2009-01-01 2010-12-31 05:09:13.860   7300
    7272 2009-01-01 2010-12-31 05:09:13.860   7300
    7273 2009-01-01 2010-12-31 05:09:13.860   7300
    7274 2009-01-01 2010-12-31 05:09:13.860   7300
    7275 2009-01-01 2010-12-31 05:09:13.860   7300
    7276 2009-01-01 2010-12-31 05:09:13.860   7300
    7277 2009-01-01 2010-12-31 05:09:13.860   7300
    7278 2009-01-01 2010-12-31 05:09:13.860   7300
    7279 2009-01-01 2010-12-31 05:09:13.860   7300
    7280 2009-01-01 2010-12-31 05:09:13.860   7300
    7281 2009-01-01 2010-12-31 05:09:13.860   7300
    7282 2009-01-01 2010-12-31 05:09:13.860   7300
    7283 2009-01-01 2010-12-31 05:09:13.860   7300
    7284 2009-01-01 2010-12-31 05:09:13.860   7300
    7285 2009-01-01 2010-12-31 05:09:13.860   7300
    7286 2009-01-01 2010-12-31 05:09:13.860   7300
    7287 2009-01-01 2010-12-31 05:09:13.860   7300
    7288 2009-01-01 2010-12-31 05:09:13.860   7300
    7289 2009-01-01 2010-12-31 05:09:13.860   7300
    7290 2009-01-01 2010-12-31 05:09:13.860   7300
    7291 2009-01-01 2010-12-31 05:09:13.860   7300
    7292 2009-01-01 2010-12-31 05:09:13.860   7300
    7293 2009-01-01 2010-12-31 05:09:13.860   7300
    7294 2009-01-01 2010-12-31 05:09:13.860   7300
    7295 2009-01-01 2010-12-31 05:09:13.860   7300
    7296 2009-01-01 2010-12-31 05:09:13.860   7300
    7297 2009-01-01 2010-12-31 05:09:13.860   7300
    7298 2009-01-01 2010-12-31 05:09:13.860   7300
    7299 2009-01-01 2010-12-31 05:09:13.860   7300
    
    [7300 rows x 3 columns]



.. code:: python

    table[table.timestamp_col < '2010-01-01'].count()




.. parsed-literal::

    3650



.. code:: python

    table[table.timestamp_col < 
          (ibis.timestamp('2010-01-01') + ibis.month(3))].count()




.. parsed-literal::

    4550



.. code:: python

    expr = (table.timestamp_col + ibis.day(1) + ibis.hour(4)).name('offset')
    table[table.timestamp_col, expr, ibis.now().name('current_time')].limit(10)




.. parsed-literal::

                   timestamp_col                  offset  \
    0    2010-04-01 00:00:00.000 2010-04-02 04:00:00.000   
    1    2010-04-01 00:01:00.000 2010-04-02 04:01:00.000   
    2    2010-04-01 00:02:00.100 2010-04-02 04:02:00.100   
    3    2010-04-01 00:03:00.300 2010-04-02 04:03:00.300   
    4    2010-04-01 00:04:00.600 2010-04-02 04:04:00.600   
    5    2010-04-01 00:05:00.100 2010-04-02 04:05:00.100   
    6    2010-04-01 00:06:00.150 2010-04-02 04:06:00.150   
    7    2010-04-01 00:07:00.210 2010-04-02 04:07:00.210   
    8    2010-04-01 00:08:00.280 2010-04-02 04:08:00.280   
    9    2010-04-01 00:09:00.360 2010-04-02 04:09:00.360   
    10   2010-04-02 00:10:00.450 2010-04-03 04:10:00.450   
    11   2010-04-02 00:11:00.450 2010-04-03 04:11:00.450   
    12   2010-04-02 00:12:00.460 2010-04-03 04:12:00.460   
    13   2010-04-02 00:13:00.480 2010-04-03 04:13:00.480   
    14   2010-04-02 00:14:00.510 2010-04-03 04:14:00.510   
    15   2010-04-02 00:15:00.550 2010-04-03 04:15:00.550   
    16   2010-04-02 00:16:00.600 2010-04-03 04:16:00.600   
    17   2010-04-02 00:17:00.660 2010-04-03 04:17:00.660   
    18   2010-04-02 00:18:00.730 2010-04-03 04:18:00.730   
    19   2010-04-02 00:19:00.810 2010-04-03 04:19:00.810   
    20   2010-04-03 00:20:00.900 2010-04-04 04:20:00.900   
    21   2010-04-03 00:21:00.900 2010-04-04 04:21:00.900   
    22   2010-04-03 00:22:00.910 2010-04-04 04:22:00.910   
    23   2010-04-03 00:23:00.930 2010-04-04 04:23:00.930   
    24   2010-04-03 00:24:00.960 2010-04-04 04:24:00.960   
    25   2010-04-03 00:25:01.000 2010-04-04 04:25:01.000   
    26   2010-04-03 00:26:01.500 2010-04-04 04:26:01.500   
    27   2010-04-03 00:27:01.110 2010-04-04 04:27:01.110   
    28   2010-04-03 00:28:01.180 2010-04-04 04:28:01.180   
    29   2010-04-03 00:29:01.260 2010-04-04 04:29:01.260   
    ...                      ...                     ...   
    7270 2009-12-29 04:40:12.600 2009-12-30 08:40:12.600   
    7271 2009-12-29 04:41:12.600 2009-12-30 08:41:12.600   
    7272 2009-12-29 04:42:12.610 2009-12-30 08:42:12.610   
    7273 2009-12-29 04:43:12.630 2009-12-30 08:43:12.630   
    7274 2009-12-29 04:44:12.660 2009-12-30 08:44:12.660   
    7275 2009-12-29 04:45:12.700 2009-12-30 08:45:12.700   
    7276 2009-12-29 04:46:12.750 2009-12-30 08:46:12.750   
    7277 2009-12-29 04:47:12.810 2009-12-30 08:47:12.810   
    7278 2009-12-29 04:48:12.880 2009-12-30 08:48:12.880   
    7279 2009-12-29 04:49:12.960 2009-12-30 08:49:12.960   
    7280 2009-12-30 04:50:13.500 2009-12-31 08:50:13.500   
    7281 2009-12-30 04:51:13.500 2009-12-31 08:51:13.500   
    7282 2009-12-30 04:52:13.600 2009-12-31 08:52:13.600   
    7283 2009-12-30 04:53:13.800 2009-12-31 08:53:13.800   
    7284 2009-12-30 04:54:13.110 2009-12-31 08:54:13.110   
    7285 2009-12-30 04:55:13.150 2009-12-31 08:55:13.150   
    7286 2009-12-30 04:56:13.200 2009-12-31 08:56:13.200   
    7287 2009-12-30 04:57:13.260 2009-12-31 08:57:13.260   
    7288 2009-12-30 04:58:13.330 2009-12-31 08:58:13.330   
    7289 2009-12-30 04:59:13.410 2009-12-31 08:59:13.410   
    7290 2009-12-31 05:00:13.500 2010-01-01 09:00:13.500   
    7291 2009-12-31 05:01:13.500 2010-01-01 09:01:13.500   
    7292 2009-12-31 05:02:13.510 2010-01-01 09:02:13.510   
    7293 2009-12-31 05:03:13.530 2010-01-01 09:03:13.530   
    7294 2009-12-31 05:04:13.560 2010-01-01 09:04:13.560   
    7295 2009-12-31 05:05:13.600 2010-01-01 09:05:13.600   
    7296 2009-12-31 05:06:13.650 2010-01-01 09:06:13.650   
    7297 2009-12-31 05:07:13.710 2010-01-01 09:07:13.710   
    7298 2009-12-31 05:08:13.780 2010-01-01 09:08:13.780   
    7299 2009-12-31 05:09:13.860 2010-01-01 09:09:13.860   
    
                       current_time  
    0    2015-08-07 11:00:34.184855  
    1    2015-08-07 11:00:34.184855  
    2    2015-08-07 11:00:34.184855  
    3    2015-08-07 11:00:34.184855  
    4    2015-08-07 11:00:34.184855  
    5    2015-08-07 11:00:34.184855  
    6    2015-08-07 11:00:34.184855  
    7    2015-08-07 11:00:34.184855  
    8    2015-08-07 11:00:34.184855  
    9    2015-08-07 11:00:34.184855  
    10   2015-08-07 11:00:34.184855  
    11   2015-08-07 11:00:34.184855  
    12   2015-08-07 11:00:34.184855  
    13   2015-08-07 11:00:34.184855  
    14   2015-08-07 11:00:34.184855  
    15   2015-08-07 11:00:34.184855  
    16   2015-08-07 11:00:34.184855  
    17   2015-08-07 11:00:34.184855  
    18   2015-08-07 11:00:34.184855  
    19   2015-08-07 11:00:34.184855  
    20   2015-08-07 11:00:34.184855  
    21   2015-08-07 11:00:34.184855  
    22   2015-08-07 11:00:34.184855  
    23   2015-08-07 11:00:34.184855  
    24   2015-08-07 11:00:34.184855  
    25   2015-08-07 11:00:34.184855  
    26   2015-08-07 11:00:34.184855  
    27   2015-08-07 11:00:34.184855  
    28   2015-08-07 11:00:34.184855  
    29   2015-08-07 11:00:34.184855  
    ...                         ...  
    7270 2015-08-07 11:00:34.184855  
    7271 2015-08-07 11:00:34.184855  
    7272 2015-08-07 11:00:34.184855  
    7273 2015-08-07 11:00:34.184855  
    7274 2015-08-07 11:00:34.184855  
    7275 2015-08-07 11:00:34.184855  
    7276 2015-08-07 11:00:34.184855  
    7277 2015-08-07 11:00:34.184855  
    7278 2015-08-07 11:00:34.184855  
    7279 2015-08-07 11:00:34.184855  
    7280 2015-08-07 11:00:34.184855  
    7281 2015-08-07 11:00:34.184855  
    7282 2015-08-07 11:00:34.184855  
    7283 2015-08-07 11:00:34.184855  
    7284 2015-08-07 11:00:34.184855  
    7285 2015-08-07 11:00:34.184855  
    7286 2015-08-07 11:00:34.184855  
    7287 2015-08-07 11:00:34.184855  
    7288 2015-08-07 11:00:34.184855  
    7289 2015-08-07 11:00:34.184855  
    7290 2015-08-07 11:00:34.184855  
    7291 2015-08-07 11:00:34.184855  
    7292 2015-08-07 11:00:34.184855  
    7293 2015-08-07 11:00:34.184855  
    7294 2015-08-07 11:00:34.184855  
    7295 2015-08-07 11:00:34.184855  
    7296 2015-08-07 11:00:34.184855  
    7297 2015-08-07 11:00:34.184855  
    7298 2015-08-07 11:00:34.184855  
    7299 2015-08-07 11:00:34.184855  
    
    [7300 rows x 3 columns]


